# 嵌入式总复习

## 1.基础知识

1. 嵌入式系统定义

   ​	以**应用**为中心、以**计算机技术**为基础、**软件硬件**可裁剪、适应应用系统对**功能**、**可靠性**、**成本**、**体积**、**功耗**和**应用环境**有严格要求的专用计算机系统

   ​	从广义上讲，凡是基于微处理器的专用软硬件系统都可以称之为嵌入式系统。即所有基于微处理器的、实现特定功能且不可被最终用户所编程的系统都可称之为嵌入式系统。

2. 嵌入式系统硬件组成

   ​	以嵌入式微处理器为核心，包括**嵌入式处理器**、**存储器**、**输入/输出接口**、**网络通信接口**和**其他外部设备接口**

3. 计算机指令集分类

   复杂指令集 **CISC**

   精简指令集 **RISC**

4. Cortex处理器分类，分别的对应领域

   **CORTEX-A 面向高端嵌入式系统**

   **CORTEX-R 面向实时嵌入式系统**

   **CORTEX-M 面向微控制器**

5. 嵌入式微处理器的数据存储格式有哪几种

   **大端格式**:字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址

   **小端格式**:低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节

6. 微处理器的体系架构有哪两种，分别的特点

   **冯·诺依曼结构**：将程序指令存储器和数据存储器合并在一起的存储器结构。

   **哈佛结构**：将程序指令存储和数据存储分开的存储器结构

7. 通过STM32系列微控制器的命名规制简述芯片的基本特点，例如STM32F407ZET6

   **STM32**：产品系列

   **F**：产品类型

   **407**：产品子类型 

   **Z**：引脚数目   Z=144脚

   **E**：闪存存储器容量 E=512KB

   **T**：封装类型  T=LQFP封装

   **6**：工作温度  6= -40至85度

## 2.STM32F407XX中断

1. 中断基本概念和工作原理

   **概念**：是指CPU在正常运行程序时，由于程序的预先安排或内外部事件，引起CPU中断正在运行的程序，而转到发生中断事件程序中。

   **工作原理**：将断点处的下一条应执行指令的地址推入堆栈保留下来，这称为保护断点，由硬件自动执行。然后，将有关的寄存器内容和标志位状态推入堆栈保留下来，这称为保护现场。保护断点和现场后即可执行中断服务程序，执行完毕，CPU由中断服务程序返回主程序，中断返回过程如下:首先恢复原保留寄存器的内容和标志位的状态，这称为恢复现场。然后恢复PC值，使CPU返回断点，这称为恢复断点。恢复现场和断点后，CPU将继续执行原主程序。

2. 中断和异常的区别？

   ​	**异常是指因为CPU内核的活动而打断了正在执行的程序**，于CPU内核来说是“同步”的，如：当指令执行了“非
   法操作”、访问被禁的内存区间、因各种错误产生的fault以及不可屏蔽中断。
   ​	**中断于CPU内核来说请求信号来自CPU内核的外面**，来自各种片上外设和外扩的外设，因此相对于CPU内核
   来说是“异步”的，如定时器外部中断。

3. 主要HAL库函数功能及应用

   ```c
   typedef struct
   {
   	uint8_t NVIC_IRQChannel;			//中断名称
   	uint8_t NVIC_IRQChannelPreemptionPriority;	//抢占优先级
   	uint8_t NVIC_IRQChannelSubPriority;		//响应优先级
   	FunctionalState NVIC_IRQChannelCmd;		//中断使能
   }NVIC_InitTypeDef;
   
   typedef struct
   {
   	__IO uint32_t IMR; /*中断屏蔽寄存器，偏移地址：0x00 */
   	__IO uint32_t EMR; /*事件屏蔽寄存器，偏移地址：0x04 */
   	__IO uint32_t RTSR; /*上升沿触发选择寄存器，偏移地址：0x08 */
   	__IO uint32_t FTSR; /*下降沿触发选择寄存器，偏移地址：0x0C */
   	__IO uint32_t SWIER; /*软件中断事件寄存器，偏移地址：0x10 */
   	__IO uint32_t PR; /*挂起寄存器，偏移地址：0x14 */
   } EXTI_TypeDef;
   
   
   void HAL_NVIC_SetPriorityGrouping (uint32_t PriorityGroup)//配置NVIC优先级分组方式    
   uint32_t HAL_NVIC_GetPriorityGrouping (void ) //获取NVIC优先级分组方式   
   void HAL_NVIC_SetPriority (IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)//设置对应中断号的组优先级和子优先级   
   void HAL_NVIC_GetPriority (IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t * pPreemptPriority, uint32_t * pSubPriority)//读取对应中断号的组优先级和子优先级  
   void HAL_NVIC_EnableIRQ (IRQn_Type IRQn) //使能对应中断号的中断
   void HAL_NVIC_DisableIRQ (IRQn_Type IRQn)//关闭对应中断号的中断
   void HAL_NVIC_SystemReset(void ) //发出系统复位中断，用来复位处理器
   uint32_t HAL_NVIC_GetPendingIRQ (IRQn_Type IRQn) //获取特定中断编号的挂起状态
   void HAL_NVIC_SetPendingIRQ (IRQn_Type IRQn) //设置特定中断编号的挂起状态
   void HAL_NVIC_ClearPendingIRQ (IRQn_Type IRQn) //清除特定中断编号的挂起状态
   uint32_t HAL_NVIC_GetActive (IRQn_Type IRQn) //获得指定中断的激活状态
   
   void HAL_GPIO_EXTI_IRQHandler (uint16_t GPIO_Pin)  //指定GPIO引脚上产生的EXTI中断处理程序
   void HAL_GPIO_EXTI_Callback (uint16_t GPIO_Pin) //指定GPIO引脚上的EXTI中断回调函数，HAL_GPIO_EXTI_IRQHandler函数中调用
   __HAL_GPIO_EXTI_GET_IT  //获取指定的EXTI线路触发的中断请求状态
   __HAL_GPIO_EXTI_CLEAR_IT //清除指定的EXTI线路触发的中断挂起位
   ```

4. 例子

   ```c
   void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
   {
       if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
   	{
   	__HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin); //清除中断请求挂起位
       HAL_GPIO_EXTI_Callback(GPIO_Pin);//调用callback函数
   	}
   }
   ```

   

5. 什么是嵌入式中断向量控制器(NVIC)，有什么用，能支持多少个中断，如何初始化外部中断？

   ​	在 Cortex-M 微控制器中，通常称为 NVIC 的嵌套向量中断控制器用于处理 Cortex-M 支持的所有中断和异常，**256**个中断

6. STM32F407的中断优先级如何判断？数值越大，优先级就越高吗？

   ​	先看**抢占优先级**，再看**响应优先级**。**高抢占优先级**中断可以打断正在进行的**低抢占优先级**中断。**抢占优先级**相同的中断，当两个中断同时发生的情况 下，哪个**响应优先级**高，哪个先执行。

   ​	数值越**小**，优先级越**高**

## 3.STM32F407XX GPIO

1. 基本概念：STM32F40xxx的I/O端口可以分为两类工作方式，用作通用输入/输出端口使用，即简称**GPIO**。

2. STM32 GPIO配置的主要步骤

   ```C
   GPIO_InitTypeDef  GPIO_InitStructure; //1.定义GPIO初始化结构体
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE); //2.打开GPIO时钟
   
   GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;
   GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//3.GPIO具体寄存器配置
   
   GPIO_Init(GPIOF, &GPIO_InitStructure);//4.GPIO初始化
   ```

3. 主要HAL库函数与应用

   ```c
   __HAL_RCC_GPIOx_CLK_ENABLE//宏定义，AHB1外设时钟使能，x取值A-G
   __HAL_RCC_GPIOx_CLK_DISABLE//宏定义，关闭AHB1外设时钟，x取值A-G
   void HAL_GPIO_Init (GPIO_TypeDef * GPIOx, GPIO_InitTypeDef * GPIO_Init) //根据GPIO_InitTypeDef结构体的参数初始化GPIO端口
   void HAL_GPIO_DeInit (GPIO_TypeDef * GPIOx, uint32_t GPIO_Pin) //将GPIO端口的功能恢复到初始状态
   GPIO_PinState HAL_GPIO_ReadPin (GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin)  //读出GPIOx中输入寄存器的值
   void HAL_GPIO_WritePin (GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState) //将数据写入GPIOx中输出寄存器
   HAL_StatusTypeDef HAL_GPIO_LockPin (GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin)//锁定GPIOx寄存器，锁定后将无法修改直到复位
   void HAL_GPIO_TogglePin (GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin)//翻转某个引脚的电平状态
   ```

4. **通过库函数配置GPIO为通用推挽输出，实现GPIO口读写操作(考)**

   ```c
   typedef struct
   {
   	uint32_t Pin; /*需要配置的GPIO引脚列表 */
   	uint32_t Mode; /*工作模式 */
   	uint32_t Pull; /*上拉和下拉参数 */
   	uint32_t Speed; /*输出速度 */
       uint32_t Alternate; /*复用功能选择*/
   }GPIO_InitTypeDef;  //GPIO_InitTypeDef结构体用于配置GPIO相关参数
   
   static void MX_GPIO_Init(void)
   {
   	GPIO_InitTypeDef GPIO_InitStruct = {0};							//初始化结构体
   	__HAL_RCC_GPIOF_CLK_ENABLE();									//F时钟使能
   	__HAL_RCC_GPIOH_CLK_ENABLE();									//H时钟使能
   	HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9|GPIO_PIN_10, GPIO_PIN_SET);	//初始化写入接口
   	GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10; 					//初始化接口
   	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;						//推挽输出
   	GPIO_InitStruct.Pull = GPIO_PULLUP;								//上拉
   	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;					//高速
   	HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
   }
   
   GPIO_PinState HAL_GPIO_ReadPin (GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin)；//读出GPIOx中输入寄存器的值
   void HAL_GPIO_WritePin (GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState//将数据写入GPIOx中输出寄存器
   ```

   

## 4.STM32F407XX 串口 

1. 基本概念与工作原理

   ​	串口按位发送和接受字节，可以在使用一根 线发送数据的同时用另一根线接收数据，它很简单又能够实现远距离通信。

2. 同步串行通讯和异步串行通讯的概念

   **同步串行通信**:以字符为传送单位，用起始位和停止位来标识每个字符的开始和结束， 传递字符的间隔不固定。通讯双方采相同的时钟，通讯前约定使用相同的传输率，使用起始位来通知字符的到来。

   **异步串行通信**:以字符为传送单位，用起始位和停止位来标识每个字符的开始和结束， 传递字符的间隔不固定。通讯双方采用不同的时钟，通讯前约定使用相同的传输率，使用起始位来通知字符的到来。

3. RS232帧格式由哪几个部分组成？逻辑电平怎样？

   **起始位、数据位、校验位、停止位**

   **1:-5V~-15 V**

   **0:+5 V～+15 V **   负逻辑

4. 微控制的串口UART模块主要包括几个部分？异步串口通信所需要的参数。

   **时钟发生器，数据接收器和数据发送器**

   **起始位、数据位、奇偶校验位、波特率**

5. 主要HAL函数

   ```c
   /*stm32f4xx_hal_uart.h中定义的USART配置参数结构体*/
   typedef struct
   {
   	uint32_t BaudRate; /*波特率*/
       uint32_t WordLength; /*数据帧长度*/
   	uint32_t StopBits; /*停止位*/
   	uint32_t Parity; /*校验位*/
   	uint32_t Mode; /*工作模式：发送、接收或者双向 */
   	uint32_t HwFlowCtl; /*硬件流控*/
   	uint32_t OverSampling; /*过采样配置*/
   } UART_InitTypeDef;
   
   HAL_StatusTypeDef HAL_UART_Init (UART_HandleTypeDef * huart) //初始化USART异步串行通信功能
   HAL_StatusTypeDef HAL_UART_Transmit (UART_HandleTypeDef * huart, uint8_t * pData, uint16_t Size, uint32_t Timeout)//启动USART开始数据发送，pData为指向发送数据缓冲区的指针，Size为需要发送的数据量，Timeout为超时参数
   HAL_StatusTypeDef HAL_UART_Receive (UART_HandleTypeDef * huart,uint8_t * pData, uint16_t Size, uint32_t Timeout)//启动USART开始接收数据，pData为指向接收数据缓冲区的指针，Size为需要接收的数据量，Timeout为超时参数
   ```

   

## 5.STM32F407XX 定时器

1. 工作原理

2. STM32定时器工作模式有哪3种？如何使用？

   **向上计数**：计数器从0计数到自动加载值，然后重新从0开始计数并且产生一个计数器溢出事件

   **向下计数**：计数器从自动装入的值开始向下计数到0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件

   **中央对齐**：计数器从0开始计数到自动装入的值-1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器溢出事件；然后再从0开始重新计数。

3. 什么是PWM

   **脉宽调制（PWM）**:利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术

4. 主要HAL库函数

   ```c
   __HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 时钟
   HAL_StatusTypeDef HAL_TIM_ PWM _Init (TIM_HandleTypeDef * htim)//初始化定时器PWM输出功能，参数为指向TIM_HandleTypeDef的指针
   ```

   

## 6.STM32F407XX 模数转换

1. 基本概念和工作原理

   ADC是一种将**模拟信号**转换为**数字信号**的转换器

2. STM32F407的ADC转换时间是由哪两个部分实现

   **采样时间**+**固定时间周期**

3. 主要HAL库函数

   ```c
   __HAL_ADC_ENABLE //宏定义，使能ADC通道，参数为(__HANDLE__ )，即指向ADC_HandleTypeDef的指针
   HAL_StatusTypeDef HAL_ADC_Init (ADC_HandleTypeDef * hadc) //初始化ADC,参数为指向ADC_HandleTypeDef的指针
   HAL_StatusTypeDef HAL_ADC_Start (ADC_HandleTypeDef * hadc) //启动ADC开始数据采样
   HAL_StatusTypeDef HAL_ADC_Stop (ADC_HandleTypeDef * hadc) //停止ADC数据采样
   ```

4. STM32模数转换如何实现？内置温度传感器和哪个模拟输入通道连接

   **ADC1的通道16**

5. 温度传感器

   ```c
   #include "main.h"
   #include "STDIO.h"
   
   ADC_HandleTypeDef hadc1;//申明ADC结构体变量
   UART_HandleTypeDef huart1;//申明UART结构体变量
   
   void SystemClock_Config(void);
   static void MX_GPIO_Init(void);
   static void MX_ADC1_Init(void);
   static void MX_USART1_UART_Init(void);//申明各个初始化函数
   
   int main(void)
   {
   	uint8_t COMBuf[50];
   	uint16_t iADCValue=0; //数值变量
   	float fV=0.0f; //电压变量
   	float fT=0.0f; //温度变量
   	HAL_Init();
   	SystemClock_Config();
       MX_GPIO_Init();
   	MX_ADC1_Init();
   	MX_USART1_UART_Init();
       while (1)
   	{
   	HAL_ADC_Start(&hadc1);//启动ADC
   	iADCValue = HAL_ADC_GetValue(&hadc1);//获取转化后的值
   	fV = iADCValue*3.3/4096;//基准电压为3.3V，12位AD对应的最大数字量为4096(2^12,因为ADC最大12位) 
   	fT = ((fV-0.76)/0.0025)+25;
       /*
      		T（℃）={（Vsense - V25）/Avg_Slope}+25
      		V25=Vsense 在 25 度时的数值（典型值为：0.76）
   		Avg_Slope=温度与 Vsense 曲线的平均斜率（单位为 mv/℃或 uv/℃）（典型值为2.5mV/℃）
       */
   	sprintf((char*)COMBuf,"vol=%.3f v,Temp=%0.2f C\r\n",fVsensor,fTemperature);//格式化
   	printf("%s",COMBuf);//标准化输出
   	HAL_Delay(1000);
     	}
   }
   ```

   

6. 编程实现对外部模拟电压的采集与计算

   ```c
   /*开启 PA 口时钟和 ADC1 时钟，设置 PA5 为模拟输入*/
   __HAL_RCC_ADC1_CLK_ENABLE(); //使能 ADC1 时钟
   __HAL_RCC_GPIOA_CLK_ENABLE(); //开启 GPIOA 时钟
   GPIO_InitTypeDef GPIO_Initure;
   GPIO_Initure.Pin=GPIO_PIN_5; //涉资PA5为输入口
   GPIO_Initure.Mode=GPIO_MODE_ANALOG; //模拟输入
   GPIO_Initure.Pull=GPIO_NOPULL; //不带上下拉
   HAL_GPIO_Init(GPIOA,&GPIO_Initure);//初始化
   
   HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc); //初始化ADC
   HAL_ADC_Start(&ADC1_Handler); //开启 ADC
   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig);//设置通道
   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc);//读取ADC值
   
   int main(void)
   {
   	u16 adcx;
   	float temp;
   	HAL_Init(); //初始化 HAL 库 
   	Stm32_Clock_Init(336,8,2,7); //设置时钟,168Mhz
   	delay_init(168); //初始化延时函数
   	uart_init(115200); //初始化 USART
   	usmart_dev.init(84); //初始化 USMART
   	MY_ADC_Init(); //初始化 ADC1 通道 5
   	while(1)
   	{
   	adcx=Get_Adc_Average(ADC_Channel_5,20);//获取通道 5 的转换值，20 次取平均
   	temp=(float)adcx*(3.3/4096); //获取计算后的带小数的实际电压值
   	adcx=temp; //赋值整数部分给 adcx 变量，因为 adcx 为 u16 整型
   	delay_ms(250);
   	}
   }
   
   
   
   ```

   

   



