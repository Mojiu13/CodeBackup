# 光栅图形学算法
- ## 直线扫描转换算法
	- dda（数值微分）扫描算法：
		- 引进图形学中的一个重要思想：增量思想
		- 当前步的y值等于前一步的y值加上斜率k
		- 要考虑k过大或过小的情况，可能导致画线太稀疏
	- Bresenham算法
		- 基本思想：该算法的思想是通过各行、各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序，计算直线与各垂直网格线的交点，然后根据误差项的符号确定该列象素中与此交点最近的象素。
		- 基本：误差项d的初值d ＝0 ，d＝d＋k一旦d≥1，就把它减去1，保证d的相对性,且在0、1之间。
		- 改进1：e=k-0.5
			- ![[Pasted image 20211024165212.png]]
		- 改进2：由于算法中只用到误差项的符号（*只关注正负 不关注具体大小，所以在式子两边都乘以2△x*），于是可以用e*2*△x来替换 e 。
			- ![[Pasted image 20211024165431.png]]
- ## 多边形扫描转换
	- 问题简介：多边形的扫描转换和区域填充这个问题是怎么样在离散的像素集上表示一个连续的二维图形
	- 多边形有两种重要的表示方法： 顶点表示和 点阵表示
		- 顶点表示：顶点表示是用多边形的顶点序列来表示多边形。这种表示直观、几何意义强、占内存少，易于进行几何变换 ||但由于它没有明确指出哪些象素在多边形内，故不能直接用于面着色
		- 点阵表示：点阵表示是用位于多边形内的象素集合来刻画多边形。这种表示丢失了许多几何信息（如边界、顶点等），但它却是光栅显示系统显示时所需的表示形式。
	- 多边形的扫描转换：把多边形的顶点表示转换为点阵表示 
		- 多边形分类：凸多边形、凹多边形、含内环的多边形
			- 凸多边形：任意两顶点间的连线均在多边形内
			- 凹多边形：任意两顶点间的连线有不在在多边形内
			- 含内环的多边形：多边形内包含多边形
	- x-扫描线算法：
		- 重要思想：扫描线思想和增量思想
		- 基本思想：按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充工作；区间的端点可以通过计算扫描线与多边形边界线的交点获得
		- 当扫描线与多边形顶点相交时，交点的取舍问题![[Pasted image 20211024172358.png]]
	- 改进的x扫描线算法：
		- 三方面考虑 ：
			- 1. 在处理一条扫描线时，仅对与它相交的多边形的边（有效边）进行求交运算
			- 2.(扫描线的连贯性)即当前扫描线与各边的交点顺序与下一条扫描线与各边的交点顺序很可能相同或非常相似
			- 3.(多边形的连贯性)当某条边与当前扫描线相交时，它很可能也与下一条扫描线相交
			- 综上，引进一套特殊的数据结构
		- 数据结构：
			- 活性边表(AET)：把与当前扫描线相交的边称为活性边，并把它们按与扫描线交点x坐标递增的顺序存放在一个链表中。
				- 结点内容（一个结点在数据结构里可用结构来表示）
					- x：当前扫描线与边的交点坐标
					- △x：从当前扫描线到下一条扫描线间x的增量
					- y max：该边所交的最高扫描线的坐标值y max
					- ![[Pasted image 20211026145427.png]]
					- ![[Pasted image 20211026145548.png]]
			- 为了方便活性边表的建立与更新，需构造一个新边表（NET），用来存放多边形的边的信息： 
				- 首先构造一个纵向链表，链表的长度为多边形所占有的最大扫描线数，链表的每个结点，称为一个吊桶，对应多边形覆盖的每一条扫描线
				- NET挂在与该边低端y值相同的扫描线桶中。也就是说，存放在该扫描线第一次出现的边
					- ![[Pasted image 20211026150018.png]]
		- 小结 ![[Pasted image 20211026151241.png]]
	- 边缘填充算法
		- 其基本思想是按任意顺序处理多边形的每条边。在处理每条边时，首先求出该边与扫描线的交点，然后将每一条扫描线上交点右方的所有像素取补。多边形的所有边处理完毕之后，填充即完成。
	- 栅栏填充算法*
		- 栅栏指的是一条过多边形顶点且与扫描线垂直的直线。它把多边形分为两半。在处理每条边与扫描线的交点时，将交点与栅栏之间的像素取补
	- 边界标志算法
		- 帧缓冲器中对多边形的每条边进行直线扫描转换，亦即对多边形边界所经过的象素打上标志然后再采用和扫描线算法类似的方法将位于多边形内的各个区段着上所需颜色由于边界标志算法不必建立维护边表以及对它进行排序，所以边界标志算法更适合硬件实现，这时它的执行速度比有序边表算法快一至两个数量级。
- ## 区域填充
	- 区域---指已经表示成点阵形式的填充图形，是象素的集合
	- 区域填充是指将区域内的一点(常称种子点)赋予给定颜色,然后将这种颜色扩展到整个区域内的过程。
	- 区域可采用 内点表示和 边界表示两种表示形式
		-  内点表示：枚举出区域内部的所有像素，内部的所有像素着同一个颜色，边界像素着与内部像素不同的颜色
		-  边界表示：枚举出边界上的所有像素，边界上的所有像素着同一个颜色，内部像素着与边界像素不同的颜色
	- 区域填充算法要求区域是连通的，因为只有在连通区域中，才可能将种子点的颜色扩展到区域内的其它点。
		- ![[Pasted image 20211026152732.png]]
		- 4向连通区域指的是从区域上一点出发，可通过四个方向，即上、下、左、右移动的组合，在不越出区域的前提下，到达区域内的任意象素
		- 8向连通区域指的是从区域内每一象素出发，可通过八个方向，即上、下、左、右、左上、右上、左下、右下这八个方向的移动的组合来到达
	- 简单种子填充算法（栈结构）
		- 算法原理：
			- 种子像素入栈，当栈非空时重复执行如下三步操作：
				- 栈顶像素出栈
				- 将出栈像素置成要填充色
				- 按左、上、右、下顺序检查与栈像素相邻的四个像素，若其中某个像素不在边界且未置成填充色，则把该像素入栈
		- ==改进的扫描线种子填充算法==：略

- ## 填充算法和扫描转换算法小结：
	- ![[Pasted image 20211026153935.png]]
- ## 走样现象与反走样技术：
	- 定义： 对直线、圆及椭圆这些最基本元素的生成速度和显示质量的改进，在图形处理系统中具有重要的应用价值但它们生成的线条具有明显的“锯齿形”即会发生走样（Liasing）现象
	- 反走样：
		- 两种思想：
			- 提高显示器分辨率：
				- 采用分辨率更高的显示设备，对解决走样现象有所帮助，因为可以使锯齿相对物体会更小一些
				- 该反走样方法是以4倍的存储器代价和扫描转换时间获得的
			- 反走样技术涉及到某种形式的“模糊”来产生更平滑的图像
				-  对于在白色背景中的黑色矩形，通过在矩形的边界附近掺入一些灰色像素，可以柔化从黑到白的尖锐变化
		- 非加权区域采样方法
			- 根据物体的覆盖率（coverage）计算像素的颜色。覆盖率是指某个像素区域被物体覆盖的比例
			- 缺点：
				- 象素的亮度与相交区域的面积成正比，而与相交区域落在象素内的位置无关，这仍然会导致锯齿效应
				- 直线条上沿理想直线方向的相邻两个象素有时会有较大的灰度差
				- （*每个像素的权值是一样的，这是它的主要缺点。所以也称非加权区域采样方法*)
		- 加权区域采样方法：
			-  思想 ：将直线段看作是具有一定宽度的狭长矩形；当直线段与像素有交时，根据相交区域与像素中心的距离来决定其对象素亮度的贡献
			-  方法：设置相交区域面积与像素中心距离的权函数（高斯函数）反映相交面积对整个像素亮度的贡献大小利用权函数积分求相交区域面积，用它乘以像素可设置的最大亮度值，即可得到该像素实际显示的亮度值
			-  离散计算方法：
				-  将一个像素划分为 n = 3×3个子象素，加权表可以取作：
				-  ![[Pasted image 20211027203047.png]]
				-  加权方案：中心子像素的加权是角子像素的4倍，是其它像素的2倍，对九个子像素的每个网格所计算出的亮度进行平均