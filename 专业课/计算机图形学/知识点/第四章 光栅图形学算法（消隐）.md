# 光栅图形学算法（消隐）
- ## 消隐算法简介和分类
	- 算法
		- Z缓冲区(Z-Buffer)算法
		- 扫描线Z-buffer算法
		- 区域子分割算法
	- 定义：当我们观察空间任何一个不透明的物体时，只能看到该物体朝向我们的那些表面，其余的表面由于被物体所遮挡我们看不到如果把可见和不可见的线都画出来，对视觉会造成多义性要消除二义性，就必须在绘制时消除被遮挡的不可见的线或面，习惯上称作消除隐藏线和隐藏面，简称为**消隐**
	- 消隐的分类
		- 按照消隐对象分类
			- 线消隐：消隐对象是物体上的边，消除的是物体上不可见的边
			- 面消隐：消隐对象是物体上的面，消除的是物体上不可兼得面，做真实感图形消隐时用面消隐
		- 按照消隐空间分类
			- 物体空间的消隐算法 
				- ![[Pasted image 20211028221536.png]]
				- 物体空间里典型的消隐算法有两个：Roberts算法和光线投射法 
					- Roberts算法数学处理严谨，计算量甚大。算法要求所有被显示的物体都是凸的，对于凹体要先分割成多个凸体的组合
					- Roberts算法基本步骤
						- 逐个的独立考虑每个物体自身，找出为其自身所遮挡的边和面（自消隐）；
						- 将每一物体上留下的边再与其它物体逐个的进行比较，以确定是完全可见还是部分或全部遮挡（两两物体消隐）；
						- 确定由于物体之间的相互贯穿等原因，是否要形成新的显示边等，从而使被显示各物体更接近现实
					- 光线投射是求光线与场景的交点，该光线就是所谓的视线（如视点与像素连成的线）一条视线与场景中的物体可能有许多交点，求出这些交点后需要排序，在前面的才能被看到。人的眼睛可以一目了然，但计算机做需要大量的运算
				- 图像空间的消隐算法
					-  以屏幕窗口内的每个像素为处理单元。确定在每一个像素处，场景中的k个物体哪一个距离观察点最近，从而用它的颜色来显示该像素
					-  算法流程图：
						-  ![[Pasted image 20211028223118.png]]
- ## 图像空间的消隐算法  
	- ### z缓冲区算法（z-Buffer）算法
		- 也叫深度缓冲器算法，属于图像空间消隐算法
		- 该算法有帧缓冲器和深度缓冲器。对应两个数组：
			- intensity（x，y）——属性数组（帧缓冲器）存储图像空间每个可见像素的光强或颜色  
			- depth（x，y）——深度数组（z-buffer）存放图像空间每个可见像素的z坐标
			- eg
				- ![[Pasted image 20211028224858.png]]
				- ![[Pasted image 20211028224905.png]]
			- 算法思想：
			- 先将Z缓冲器中各单元的初始值置为最小值。当要改变某个像素的颜色值时，首先检查当前多边形的深度值是否大于该像素原来的深度值（保存在该像素所对应的Z缓冲器的单元中）如果大于原来的z值，说明当前多边形更靠近观察点，用它的颜色替换像素原来的颜色
			- 算法流程
				- ![[Pasted image 20211028225116.png]]
			- 优点：
				-  （1）Z-Buffer算法比较简单，也很直观
				-  （2）在象素级上以近物取代远物。与物体在屏幕上的出现顺序是无关紧要的，有利于硬件实现
			- 缺点：
				-  （1）占用空间大
				-  （2）没有利用图形的相关性与连续性，这是z-buffer算法的严重缺陷
				-  （3）更为严重的是，该算法是在像素级上的消隐算法
	- ### 只用一个深度缓存变量zb的改进算法
		-   背景：一般认为，z-Buffer算法需要开一个与图象大小相等的缓存数组ZB，实际上，可以改进算法，只用一个深度缓存变量zb
		-   算法流程：![[Pasted image 20211029084847.png]]
		-   关键问题：
			-   1.判断象素点(i,j)是否在pk的投影多边形之内，不是一件容易的事。节省了空间但牺牲了时间。计算机的很多问题就是在时间和空间上找平衡
			-   2.另一个问题计算多边形Pk在点（i，j）处的深度。设多边形Pk的平面方程为：![[Pasted image 20211029085646.png]]
	-   ### 点与多边形的包含性检测：
		-   1.射线法
			-   由被测点向y=-无穷方向作射线，交点是奇数，则被测点在多边形内部。交点个数是偶数表示在多边形外部
			-   若射线正好经过多边形的顶点，则采用“左开右闭”的原则来实现即：当射线与某条边的顶点相交时，若边在射线的左侧，交点有效，计数；若边在射线的右侧，交点无效，不计数
			-   ![[Pasted image 20211029132205.png]]
			-   弊端：
				-   计算量大
				-   不稳定
		- 2.弧长法
			- 以p点为圆心，作单位圆，把边投影到单位圆上，对应一段段弧长，规定逆时针为正，顺时针为负，计算弧长代数和
				- 代数和为0 ，点在多边形外部
				- 代数和为2pi，点在多边形内部
				- 代数和为pi，点在多边形内部
				- 思考与问题：这个算法为什么是稳定的？假如算出来后代数和不是0，而是0.2或0.1，（只考虑是否接近0）那么基本上可以断定这个点在外部，可以认为是有计算误差引起的，实际上是0。但这个算法效率也不高，问题是算弧长并不容易，因此又派生出一个新的方法—以顶点符号为基础的弧长累加方法
		- 3.以定点符号为基础的弧长累加方法
			-  简单来说：根据线段跨过的象限确定弧长
			- ![[Pasted image 20211029135313.png]]
			- ![[Pasted image 20211029135439.png]]
			- 同一个象限认为是0，跨过一个象限是pi/2，跨过二个象限是pi。这样当要计算代数和的时候，就不要去投影了，只要根据点所在的象限一下子就判断出多少度，这样几乎没有什么计算量，只有一些简单的判断，效率非常高	
	- ### 区间扫描线算法
		-  思想：扫描线的交点把这条扫描线分成了若干个区间，每个区间上必然是同样一种颜色。如果把扫描线和多边形的这些交点都求出来，对每个区间，只要判断一个像素的要画什么颜色，那么整个区间的颜色都解决了，这就是区间扫描线算法的主要思想
			-  ![[Pasted image 20211031145812.png]]
		-  情况分类：
			-  小区间上没有任何多边形，用背景色显示   
			-  小区间只有一个多边形，显示该多边形的颜色
			-  小区间上存在两个或两个以上的多边，必须通过深度测试判断哪个多边形可见
		-  问题思考：
			-  求交点？增量算法简化求交
			-  每段区间要求z值最大的面。如何知道区间上有哪个多边形和区间相关；利用之前的特殊数据结构
	-  ### warnock算法
		-  思想：分而治之的思想 利用了堆栈的数据结构  把物体投影到全屏幕窗口上，然后递归分割窗口，直到窗口内目标足够简单，可以显示为止
		-  问题思考：
			-  什么情况下，画面足够简单可以立即显示：
				-  1.窗口中仅包含一个多边形
				-  2.窗口与一个多边形相交，且没有其他多边形
				-  3.窗口被一个多边形包围
				-  4.窗口与一个多边形分离（窗口内无物体，显示背景色）
			-  如何判别一个多边形与窗口是分离
				-  ![[Pasted image 20211031151100.png]]
			-  如何判别一个多边形在窗口内
				-  ![[Pasted image 20211031151105.png]]
		-  窗口有多个多边形投影面
			-  利用堆栈思想
			-  算法步骤：
				-  1. 窗口内没有物体则按背景色显示
				-  2.若窗口内只有一个面，则把该面显示出来
				-  3.窗口内含有两个以上的面，则把窗口等分成四个子窗口。对每个小窗口再做上述同样的处理。这样反复地进行下去